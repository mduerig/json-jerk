{"name":"Json-jerk","tagline":"Json Jerk is a flexible and fast JSON parser.","body":"Json Jerk\r\n=========\r\nJson Jerk is a flexible and fast JSON parser. It consists of several composable parts\r\nfor tokenizing, (un)escaping, parsing, and handling of semantic actions. Furthermore\r\nit provides a light weight and type safe object model for JSON documents.\r\n\r\nA simple example\r\n----------------\r\nThe following example shows the simplest way to parse a JSON string:\r\n\r\n    String json = \"{\\\"hello\\\":\\\"world\\\"}\";\r\n    JsonObject jsonObject = FullJsonParser.parseObject(new UnescapingJsonTokenizer(json));\r\n\r\n`FullJsonParser` is a utility class which provides methods for parsing (parts of) JSON\r\ndocuments. Its `parseObject` method takes a `JsonTokenizer` as argument and tries to\r\nparse an object from the input. In this case we've used a `UnescapingJsonTokenizer`\r\ninstance for the tokenizer. This class unescapes all escape sequences it encounters.\r\nWhile this is generally the right thing to do, it can be very expensive in terms of\r\nperformance. If we'd rather want the tokenizer not to unescape, we would use an instance\r\nof `DefaultJsonTokenizer`.\r\n\r\nIf parsing is successful, it results in a `JsonObject` instance. `JsonObject` is a\r\nsubclass of `JsonValue` and represents a JSON object. There is also a `JsonArray`\r\nsubclass and a `JsonAtom` subclass which represent JSON arrays and primitive JSON\r\nvalues, respectively.\r\n\r\nThe object model\r\n----------------\r\nTo see how to use the `JsonValue` classes consider this more complex example:\r\n\r\n    String json =\r\n        \"{\\\"string\\\":\\\"value\\\",\" +\r\n        \"\\\"number\\\":1.42,\" +\r\n        \"\\\"null\\\":null,\" +\r\n        \"\\\"false\\\":false,\" +\r\n        \"\\\"true\\\":true,\" +\r\n        \"\\\"nestedArray\\\":[[],[[],[]]],\" +\r\n        \"\\\"array\\\":[1,2,3],\" +\r\n        \"\\\"object\\\":{\" +\r\n            \"\\\"size\\\":212,\" +\r\n            \"\\\"empty\\\":\\\"\\\",\" +\r\n            \"\\\"array\\\":[1,2,3,{\\\"number\\\":142,\\\"array\\\":[1,2,3,{}]}],\" +\r\n            \"\\\"object\\\":{}\" +\r\n        \"}}\";\r\n\r\n    JsonObject jsonObject = FullJsonParser.parseObject(new UnescapingJsonTokenizer(json));\r\n    StringBuilder sb = new StringBuilder();\r\n    printObject(jsonObject, sb);\r\n\r\nThe `printObject` method prints all members of the JSON object by calling `printValue`\r\nfor each of them. The `printValue` method in turn determines the actual type of the\r\n`JsonValue` and calls one of the respective print methods.\r\n\r\n    private static void printValue(JsonValue jsonValue, StringBuilder sb) {\r\n        switch (jsonValue.type()) {\r\n            case OBJECT:\r\n                printObject(jsonValue.asObject(), sb);\r\n                break;\r\n            case ARRAY:\r\n                printArray(jsonValue.asArray(), sb);\r\n                break;\r\n            default:\r\n                printAtom(jsonValue.asAtom(), sb);\r\n        }\r\n    }\r\n\r\n    private static void printObject(JsonObject object, StringBuilder sb) {\r\n        sb.append('{');\r\n        String separator = \"\";\r\n        for (Entry<String, JsonValue> pair : object.value().entrySet()) {\r\n            sb.append(separator);\r\n            separator = \",\";\r\n            sb.append('\"').append(pair.getKey()).append(\"\\\":\");\r\n            printValue(pair.getValue(), sb);\r\n        }\r\n        sb.append('}');\r\n    }\r\n\r\n    private static void printArray(JsonArray array, StringBuilder sb) {\r\n        sb.append('[');\r\n        String separator = \"\";\r\n        for (JsonValue value : array.value()) {\r\n            sb.append(separator);\r\n            separator = \",\";\r\n            printValue(value, sb);\r\n        }\r\n        sb.append(']');\r\n    }\r\n\r\n    private static void printAtom(JsonAtom atom, StringBuilder sb) {\r\n        if (atom.type() == Type.STRING) {\r\n            sb.append('\"').append(JsonValue.escape(atom.value())).append('\"');\r\n        }\r\n        else {\r\n            sb.append(atom.value());\r\n        }\r\n    }\r\n\r\nUsing a visitor on the object model\r\n-----------------------------------\r\nAnother way to travers the object model is by implementing a 'JsonValue.Visitor' and\r\npassing it to the `accept` method of `JsonValue`. The following code - as the previous -\r\ntranslate the object model back to JSON.\r\n\r\n    final StringBuilder sb = new StringBuilder();\r\n    jsonObject.accept(new Visitor() {\r\n        @Override\r\n        public void visit(JsonAtom atom) {\r\n            if (atom.type() == Type.STRING) {\r\n                sb.append('\"').append(JsonValue.escape(atom.value())).append('\"');\r\n            }\r\n            else {\r\n                sb.append(atom.value());\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void visit(JsonArray array) {\r\n            sb.append('[');\r\n            String separator = \"\";\r\n            for (JsonValue value : array.value()) {\r\n                sb.append(separator);\r\n                separator = \",\";\r\n                value.accept(this);\r\n            }\r\n            sb.append(']');\r\n        }\r\n\r\n        @Override\r\n        public void visit(JsonObject object) {\r\n            sb.append('{');\r\n            String separator = \"\";\r\n            for (Entry<String, JsonValue> entry : object.value().entrySet()) {\r\n                sb.append(separator);\r\n                separator = \",\";\r\n                sb.append('\"').append(entry.getKey()).append(\"\\\":\");\r\n                entry.getValue().accept(this);\r\n            }\r\n            sb.append('}');\r\n        }\r\n    });\r\n\r\nBoth examples use the `escape` method of `JsonValue` for escaping strings.\r\n\r\nAlthough these examples generate JSON from `JsonValue`, there is no need to\r\ndo this manually in general. In fact, the `toJson` method of `JsonValue` does\r\nexactly this: it returns a JSON string.\r\n\r\nUsing call backs\r\n----------------\r\nThe previous examples all created an object model of `JsonValue`s from a JSON\r\nstring. This is not the only way to parse a JSON document though. With Json\r\nJerk we can also use an `JsonHandler` to get notified of parse events. Inside\r\nour `JsonHandler` we can then do whatever we want to handle these events. We\r\ncould for example build a custom object model.\r\n\r\nSuppose we want to separately collect the keys of all values, object and\r\narrays of a JSON document. That is, we want to flat map these keys. Here is\r\nhow:\r\n\r\n    String json = \"{\\\"one\\\":1,\\\"two\\\":{\\\"three\\\":3,\\\"four\\\":[]}}\";\r\n    final Set<String> atoms = new HashSet<String>();\r\n    final Set<String> objects = new HashSet<String>();\r\n    final Set<String> arrays = new HashSet<String>();\r\n\r\n    new JsonParser(new JsonHandler(){\r\n        @Override\r\n        public void atom(Token key, Token value) {\r\n            atoms.add(key.text());\r\n        }\r\n\r\n        @Override\r\n        public void object(JsonParser parser, Token key, JsonTokenizer tokenizer) {\r\n            objects.add(key.text());\r\n            super.object(parser, key, tokenizer);\r\n        }\r\n\r\n        @Override\r\n        public void array(JsonParser parser, Token key, JsonTokenizer tokenizer) {\r\n            arrays.add(key.text());\r\n            super.array(parser, key, tokenizer);\r\n        }\r\n    }).parseObject(new UnescapingJsonTokenizer(json));\r\n\r\nThe `JsonParser` calls the corresponding call back on the `JsonHandler` whenever\r\nit parses the respective JSON element. In contrast to other JSON parser, Json\r\nJerk does not do recursive decent automatically. That is, when it encounters\r\nan object or an array, it will call the corresponding call back of the\r\n`JsonHandler`. It is then the handlers responsibility to parser the object or\r\narray itself. The easiest way to do this is to use the `JsonParser` and the\r\n`JsonTokenizer` passed to the handler. This is exactly what the method's super\r\nmethod does. So calling super is actually even easier.\r\n\r\nSuppose we want to collect the keys as above but this time we want skip all keys\r\nfrom nested structures. To achieve this we need to change the parsing of nested\r\nstructures: instead of calling super which effectively continues parsing with the\r\ncurrent parser, we need to parse the nested structures with a different parser\r\nwhich does nothing but skip the whole structure:\r\n\r\n    String json = \"{\\\"one\\\":1,\\\"two\\\":{\\\"three\\\":3,\\\"four\\\":[]}}\";\r\n    final Set<String> atoms = new HashSet<String>();\r\n    final Set<String> objects = new HashSet<String>();\r\n    final Set<String> arrays = new HashSet<String>();\r\n\r\n    new JsonParser(new JsonHandler(){\r\n        @Override\r\n        public void atom(Token key, Token value) {\r\n            atoms.add(key.text());\r\n        }\r\n\r\n        @Override\r\n        public void object(JsonParser parser, Token key, JsonTokenizer tokenizer) {\r\n            objects.add(key.text());\r\n            new JsonParser(new JsonHandler()).parseObject(tokenizer);\r\n        }\r\n\r\n        @Override\r\n        public void array(JsonParser parser, Token key, JsonTokenizer tokenizer) {\r\n            arrays.add(key.text());\r\n            new JsonParser(new JsonHandler()).parseArray(tokenizer);\r\n        }\r\n    }).parseObject(new UnescapingJsonTokenizer(json));\r\n\r\nIn this example the super calls have been replaced by calls to new parsers which\r\nhave an empty `JsonHandler` and thus do nothing but skip the current array or\r\nobject.\r\n\r\nIn more complex scenarios, nested objects and arrays may be parsed with specific\r\n`JsonHandler`s. The `FullJsonParser` used in earlier examples to build the object\r\nmodels from JSON documents is implemented in this way: it uses a `JsonParser` and\r\nsupplied it with different `JsonHandler` instances to build the hierarchical\r\nobject model consisting of `JsonValue` objects.\r\n\r\nBe lazy: level order parsing\r\n----------------------------\r\nNot having the parser to recursively descent on nested structures opens up some\r\nunexpected possibilities: we don't actually need to parse a nested object on a\r\ncall to `JsonHandler.object`. What we could do instead, is to keep the state\r\nof the `JsonTokenizer` and parse it later when needed.\r\n\r\nThis is what the `LevelOrderJsonParser` does. From the outside, this parser look\r\nthe same as the `FullJsonParser`. In contrast to the latter however, it does not\r\nparse nested structures right away but rather keeps a reference to a parser for\r\nthem. When a nested structure is accessed through the corresponding `JsonValue`,\r\nthat parser is invoked to parse the structure. This lazy approach  results in a\r\nlevel order traversal of the JSON document compared to the post order traversal\r\ndone by the `FullJsonParser`. Level order traversal can be beneficial if one\r\nneeds to find all sub objects of a given objects without wanting to cope with\r\ndeeper levels.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}